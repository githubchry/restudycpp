
/*
# 异常：用还是不用?
开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。
如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。

异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误。
比如，在说容器的时候，有一个没提的地方是，在能使用[] 运算符的地方，C++ 的标准容器也提供了 at 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段:
    try {
        map v;
        v.at(3);
    } catch (const out_of_range& e) {
        std::cerr << e.what() << std::endl;
    }
C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。
vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。
这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。

只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc，除非你明确知道你的目标运行环境不会产生这个异常。

虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：
    你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。
由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。
在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。

# 如果不用
没有异常的C语言里面需要大量的判断错误的代码，零散分布在代码各处，以解决出错后资源回收/反初始化等问题。
事实上，如果出错位置离处理错误的位置相差很远的话，每一层的函数调用里都得有判断错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰……
如果C++不使用异常实现相同逻辑的代码，结果也差不多：因为构造函数是没有返回值的，无法知道构造成功还是失败，只能另外写类似C语言的初始化函数做构造操作并判断成功与否……

# 如何使用
异常处理并不意味着需要写显式的 try 和 catch。
如果你不确定什么是“异常安全”，我们先来温习一下概念：
    异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。

只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。
我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。

今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。
代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。
典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。

# 对避免异常带来的问题有几点建议：
    1. 写异常安全的代码，尤其在模板里。
       可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。
    2. 如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。
       确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备处理哪些异常。
    3. 对于肯定不会抛出异常的代码，将其标为 noexcept。
       注意类的特殊成员（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept的话。
       所以，像 swap 这样的成员函数应当尽可能标成 noexcept。
 */

#include <iostream>

class matrix {

public:
    matrix(size_t rows, size_t cols) : rows_(rows), cols_(cols) {
        std::cout << "matrix()" << std::endl;
        data_ = new float[rows * cols];
        // 如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。
        // 这种情况下，在 catch 捕捉到这个异常**之前**，所有的栈上对象会全部被析构，资源全部被自动清理。
        // => 不会造成内存泄漏
    }

    ~matrix() {
        std::cout << "~matrix()" << std::endl;
        delete[] data_;
    }


    matrix operator*(const matrix &rhs) {
        if (cols_ != rhs.rows_) {
            throw std::runtime_error("matrix sizes mismatch");
            // throw异常，后面语句不会执行，对象 c 根本不会被构造出来 => 不会造成内存泄漏
        }
        matrix result(rows_, rhs.cols_); // 如果失败，result 对象根本没有构造出来  => 不会造成内存泄漏
        // 进行矩阵乘法运算

        return result;
    }

private:
    float *data_;
    size_t rows_;
    size_t cols_;
};

int main() {
    {
        matrix a(11, 10);
        matrix b(10, 11);
        matrix c = a * b;
    }

    std::cout << "exception testing" << std::endl;

    try {
        matrix a(10, 10);
        matrix b(11, 11);
        matrix c = a * b;
        std::cout << "乘法计算里面发生异常，这里不会被执行" << std::endl;
    } catch (const std::runtime_error& e) {
        std::cout << "在catch到异常前，所有的栈上对象会全部被析构，资源全部被自动清理" << std::endl;
        std::cerr << e.what() << std::endl;
    }


    return 0; // 结果：.....
}