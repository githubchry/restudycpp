

# 什么是迭代器？

迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。
按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达。

假设容器的成员函数 begin 返回的类型是 I，end 返回的类型是 S，对于对象类型 I 和 S有以下要求：

- I 对象支持 * 操作，解引用取得容器内的某个对象。
- I 对象支持 ++，指向下一个对象。
- I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）。

注意在 C++17 之前，begin 和 end 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。

上面的类型 I，多多少少就是一个满足`输入迭代器（input iterator）`的类型了。

输入迭代器不要求对同一迭代器可以多次使用 * 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。
如果取消这些限制、允许多次访问的话，那迭代器同时满足了`前向迭代器（forward iterator）`。

一个前向迭代器的类型，如果同时支持 --（前置及后置），回到前一个对象，那它就是个`双向迭代器（bidirectional iterator）`。也就是说，可以正向遍历，也可以反向遍历。

一个双向迭代器，如果额外支持在整数类型上的 +、-、+=、-=，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个`随机访问迭代器（random-access iterator）`。

一个随机访问迭代器 i 和一个整数 n，在 *i 可解引用且 i + n 是合法迭代器的前提下，如果额外还满足 *(std::addressof(*i) + n) 等价于 *(i + n)，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个`连续迭代器（contiguous iterator）`。

以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 *i 只能作为左值来写而不能读，那它就是个`输出迭代器（output iterator）`。

而比输入迭代器和输出迭代器更底层的概念，就是`迭代器(iterator)`了。基本要求是：

- 对象可以被拷贝构造、拷贝赋值和析构。
- 对象支持 * 运算符。
- 对象支持前置 ++ 运算符。

迭代器类型的关系可从下图中全部看到：

```
                   ┌────────────┐
                   │   迭代器    │
                   └───╱────╲───┘
                      ╱      ╲
          ┌──────────╱─┐     ┌╲───────────┐
  用*读取  │  输入迭代器  │     │  输出迭代器  │  用*输出
          └─────┬──────┘     └────────────┘
                │
          ┌─────↓──────┐     ┌────────────┐
 可反复读取 │  前向迭代器  ├────→┤  双向迭代器  │  支持--
          └────────────┘     └─────┬──────┘
                                   │
         ┌─────────────┐    ┌──────↓──────┐
 存储连续　│ 随机访问迭代器 ├←───┤  连续迭代器   │  支持跳跃和比较
         └─────────────┘    └─────────────┘

```



```mermaid
graph TB
  拷贝构造/拷贝赋值/析构/支持++和*的对象-->iterator(迭代器)
  iterator(迭代器)--用*读取--> input[输入迭代器];
  iterator(迭代器)--用*输出-->output[输出迭代器];
  
  subgraph  
  input[输入迭代器]
  output[输出迭代器]
  end
  
  input[输入迭代器]--可反复读取-->forward[前向迭代器]--支持-- -->bidirectional[双向迭代器]--支持跳跃和比较-->random-access[连续迭代器]--存储连续-->contiguous[随机访问迭代器];

```

迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。

# 常用迭代器

最常用的迭代器就是容器的 iterator 类型了。

## 输入迭代器

以我们学过的顺序容器为例，它们都定义了嵌套的 iterator 类型和 const_iterator 类型。一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：

- `forward_list::iterator` 可以满足到前向迭代器（单向链表不能反向遍历）。
- `list::iterator` 可以满足到双向迭代器（链表不能快速跳转）。 
- `vector::iterator` 和 `array::iterator` 可以满足到连续迭代器。 
- `deque::iterator `可以满足到随机访问迭代器（记得它的内存只有部分连续）。

## 输出迭代器

很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是ostream_iterator，方便我们把容器内容“拷贝”到一个输出流。

